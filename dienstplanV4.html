<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dienstplan-Ersteller</title>
    <!-- Tailwind CSS CDN für modernes Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Styling für Kalendertage */
        .calendar-day:not(.is-not-current-month) {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .calendar-day:not(.is-not-current-month):hover {
            background-color: #e2e8f0; /* Leichtes Grau für Hover */
        }
        .calendar-day.has-event {
            cursor: grab;
        }
        .calendar-day.is-dragging {
            opacity: 0.5;
        }
        .calendar-day.drag-over {
            border: 2px dashed #4b5563; /* Graue gestrichelte Linie für Drop-Zone */
        }

        /* Styling für das Dialog-Modal */
        dialog::backdrop {
            background-color: rgba(17, 24, 39, 0.5); /* Dunkler, halbtransparenter Hintergrund */
        }

        /* Styling für das Drag-Ghost-Element bei Touch-Events */
        #drag-ghost {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            background-color: rgba(100, 116, 139, 0.7);
            color: white;
            padding: 8px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            transform: translate(-50%, -50%);
            display: none;
        }
        
        /* CSS für den Ladespinner */
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <!-- Hauptcontainer der Anwendung -->
    <div class="bg-white rounded-3xl shadow-xl w-full max-w-6xl p-8 grid lg:grid-cols-2 gap-8">
        
        <!-- Kalender-Bereich -->
        <div>
            <div class="flex justify-between items-center mb-6">
                <button id="prevMonth" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-colors duration-200">
                    &lt;
                </button>
                <h2 id="currentMonthAndYear" class="text-2xl font-bold text-gray-800"></h2>
                <button id="nextMonth" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-colors duration-200">
                    &gt;
                </button>
            </div>
            
            <!-- Die Tagesabkürzungen mit dem neuen Styling -->
            <div class="grid grid-cols-7 text-center font-semibold text-white mb-2">
                <div class="p-2 bg-emerald-500 rounded-l-lg">Mo</div>
                <div class="p-2 bg-emerald-500">Di</div>
                <div class="p-2 bg-emerald-500">Mi</div>
                <div class="p-2 bg-emerald-500">Do</div>
                <div class="p-2 bg-emerald-500">Fr</div>
                <!-- Angepasste Farbe für Samstag -->
                <div class="p-2 bg-emerald-500 text-red-600">Sa</div>
                <!-- Angepasste Farbe für Sonntag -->
                <div class="p-2 bg-emerald-500 rounded-r-lg text-red-600">So</div>
            </div>
            
            <div id="calendar" class="grid grid-cols-7 gap-1 text-center">
                <!-- Kalendertage werden hier von JavaScript eingefügt -->
            </div>
        </div>

        <!-- Termin-Liste und Download-Bereich -->
        <div class="bg-gray-50 p-6 rounded-2xl shadow-inner flex flex-col h-full">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Dienste (<span id="totalEvents">0</span>)</h3>
            <ul id="eventList" class="space-y-3 flex-grow overflow-y-auto pr-2">
                <!-- Termin-Einträge werden hier von JavaScript eingefügt -->
            </ul>
            <div class="mt-6 pt-4 border-t border-gray-200 flex gap-4">
                <!-- Die Positionen der Buttons wurden getauscht -->
                <button id="controlButton" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-xl shadow-md transition-colors duration-200">
                    Kontrolle
                </button>
                <button id="downloadIcs" class="flex-1 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-xl shadow-md transition-colors duration-200">
                    Download Dienstplan
                </button>
                <!-- Benachrichtigungsbox für den Download-Fehler -->
                <div id="messageBox" class="mt-2 hidden text-sm bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded-xl" role="alert">
                    Es sind keine Termine zum Herunterladen vorhanden.
                </div>
            </div>
        </div>
        
    </div>

    <!-- Dialog-Modal für die Termin-Auswahl -->
    <dialog id="eventModal" class="p-8 w-full max-w-md rounded-3xl shadow-2xl">
        <div class="flex justify-between items-center mb-6">
            <h3 class="text-xl font-bold text-gray-800">Schicht für <span id="modalDate"></span></h3>
            <!-- Aktualisierter Close Button mit SVG-Icon -->
            <button id="closeModal" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 hover:text-gray-700 transition-colors duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        
        <!-- Ein Container für alle Modal-Inhalte, um einheitliche Abstände zu gewährleisten -->
        <div class="flex flex-col gap-4">
            <p class="text-gray-600">Wähle eine Schicht:</p>
            <div class="grid grid-cols-3 gap-3" id="dayShiftButtons">
                <button data-shift="RD1" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RD1</button>
                <button data-shift="RD2" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RD2</button>
                <button data-shift="RD3" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RD3</button>
                <button data-shift="RD4" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RD4</button>
                <button data-shift="RD5" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RD5</button>
            </div>
            
            <!-- Trennlinie ohne zusätzliche Margins, da der Abstand durch den Parent-Container geregelt wird -->
            <hr class="border-t-2 border-emerald-500">

            <div class="grid grid-cols-3 gap-3" id="nightShiftButtons">
                <button data-shift="RDN1" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RDN1</button>
                <button data-shift="RDN2" class="shift-btn bg-gray-200 hover:bg-emerald-200 text-gray-700 font-medium py-3 rounded-lg transition-colors">RDN2</button>
            </div>

            <!-- Trennlinie vor dem Freitextfeld -->
            <hr class="border-t-2 border-emerald-500">

            <p class="text-gray-600">Oder Freitext:</p>
            <div class="flex gap-2">
                <input type="text" id="freeText" placeholder="Z.B. Urlaub, Fortbildung" class="flex-grow p-3 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-shadow">
                <button id="saveFreeText" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg transition-colors">Speichern</button>
            </div>
        </div>
    </dialog>
    
    <!-- Neues Pop-up für das Easter Egg -->
    <dialog id="easterEggModal" class="p-8 w-full max-w-md rounded-3xl shadow-2xl text-center">
        <div class="flex flex-col items-center gap-6">
            <!-- Lorbeerkranz SVG als Ersatz für den Tiroler Adler -->
            <svg class="h-24 w-24 text-green-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 2C8.134 2 5 5.134 5 9c0 2.455 1.258 4.646 3.197 5.927l-2.613 2.614c-.39.391-.39 1.024 0 1.415.391.39 1.024.39 1.415 0l2.614-2.613C9.354 17.742 11.545 19 14 19c3.866 0 7-3.134 7-7s-3.134-7-7-7zm0 14c-2.757 0-5-2.243-5-5s2.243-5 5-5 5 2.243 5 5-2.243 5-5 5zm5.727-8.106l-2.02-2.02c-.391-.391-1.024-.391-1.415 0-.39.39-.39 1.024 0 1.414l2.02 2.02c.39.39 1.024.39 1.414 0 .391-.39.391-1.024 0-1.414zM8.273 8.106c-.39-.39-.39-1.024 0-1.414s1.024-.39 1.414 0l2.02 2.02c.391.39 0 1.024-.39 1.414s-1.024 0-1.414-.39l-2.02-2.02z"/>
            </svg>
            <p class="text-gray-800 text-lg font-bold">Mit diesem Dienst trägst du die Bürde des Landes Tirol. Die Bevölkerung kann stolz auf dich sein</p>
            <button id="closeEasterEggModal" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-xl shadow-md transition-colors duration-200">
                Schließen
            </button>
        </div>
    </dialog>

    <!-- Das Ghost-Element für das Drag-and-Drop bei Touch-Events -->
    <div id="drag-ghost"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM-Elemente abrufen
            const calendarEl = document.getElementById('calendar');
            const currentMonthAndYearEl = document.getElementById('currentMonthAndYear');
            const prevMonthBtn = document.getElementById('prevMonth');
            const nextMonthBtn = document.getElementById('nextMonth');
            const eventModal = document.getElementById('eventModal');
            const modalDateEl = document.getElementById('modalDate');
            const dayShiftButtonsEl = document.getElementById('dayShiftButtons');
            const nightShiftButtonsEl = document.getElementById('nightShiftButtons');
            const freeTextEl = document.getElementById('freeText');
            const saveFreeTextBtn = document.getElementById('saveFreeText');
            const closeModalBtn = document.getElementById('closeModal');
            const eventListEl = document.getElementById('eventList');
            const totalEventsEl = document.getElementById('totalEvents');
            const downloadIcsBtn = document.getElementById('downloadIcs');
            const controlButton = document.getElementById('controlButton');
            const messageBox = document.getElementById('messageBox');
            const easterEggModal = document.getElementById('easterEggModal');
            const closeEasterEggModalBtn = document.getElementById('closeEasterEggModal');
            const dragGhost = document.getElementById('drag-ghost');

            // Zustand verwalten
            let currentDate = new Date();
            currentDate.setMonth(currentDate.getMonth() + 2);
            let selectedDate = null;
            let events = [];

            // Zustand für Drag-and-Drop
            let draggedEventData = null;
            let dragTargetEl = null;

            // Timer für Long-Touch-Erkennung
            let longPressTimer = null;
            const longPressDuration = 500; // ms
            let touchStartX = 0;
            let touchStartY = 0;

            const predefinedShifts = ["RD1", "RD2", "RD3", "RD4", "RD5", "RDN1", "RDN2"];

            function showMessage(message) {
                messageBox.textContent = message;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000);
            }

            function openModal(date) {
                selectedDate = date;
                modalDateEl.textContent = new Date(selectedDate).toLocaleDateString('de-DE', { dateStyle: 'long' });
                eventModal.showModal();
            }

            function closeModal() {
                eventModal.close();
                selectedDate = null;
                freeTextEl.value = '';
            }

            function closeEasterEggModal() {
                easterEggModal.close();
            }

            // Hilfsfunktionen für die TTS-Integration
            function base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcm16, sampleRate) {
                const numSamples = pcm16.length;
                const buffer = new ArrayBuffer(44 + numSamples * 2);
                const view = new DataView(buffer);

                // RIFF-Header
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + numSamples * 2, true);
                writeString(view, 8, 'WAVE');

                // fmt-Sub-Chunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true); // AudioFormat: 1 = PCM
                view.setUint16(22, 1, true); // NumChannels: 1
                view.setUint32(24, sampleRate, true); // SampleRate
                view.setUint32(28, sampleRate * 2, true); // ByteRate
                view.setUint16(32, 2, true); // BlockAlign
                view.setUint16(34, 16, true); // BitsPerSample

                // data-Sub-Chunk
                writeString(view, 36, 'data');
                view.setUint32(40, numSamples * 2, true);

                // PCM-Daten
                for (let i = 0; i < numSamples; i++) {
                    view.setInt16(44 + i * 2, pcm16[i], true);
                }

                return new Blob([view], { type: 'audio/wav' });

                function writeString(view, offset, string) {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                }
            }

            // Funktion zur Sprachausgabe
            async function sayText(text, buttonEl) {
                const originalContent = buttonEl.innerHTML;
                buttonEl.innerHTML = '<div class="spinner"></div>';
                buttonEl.disabled = true;

                try {
                    const payload = {
                        contents: [{
                            parts: [{ text: text }]
                        }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    // Ändern der Stimme auf Leda
                                    prebuiltVoiceConfig: { voiceName: "Leda" }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const apiKey = "";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();
                    
                    const part = result?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        
                        const audio = new Audio(audioUrl);
                        audio.play();
                        
                        // Nach dem Abspielen den Speicher wieder freigeben
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                        };
                    } else {
                        throw new Error('Ungültige Audio-Daten erhalten.');
                    }
                } catch (error) {
                    console.error('Fehler bei der Sprachsynthese:', error);
                    showMessage('Fehler bei der Sprachsynthese.');
                } finally {
                    buttonEl.innerHTML = originalContent;
                    buttonEl.disabled = false;
                }
            }
            
            // Hilfsfunktion zur Ermittlung der ISO-Wochennummer
            // Quelle: https://weeknumber.net/how-to/javascript
            function getISOWeek(date) {
                const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
                d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
                const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
                return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            }

            // Funktion zur Sprachausgabe aller Termine
            async function readAllEvents(buttonEl) {
                if (events.length === 0) {
                    showMessage('Es sind keine Termine vorhanden, die vorgelesen werden können.');
                    return;
                }
                
                const originalContent = buttonEl.innerHTML;
                buttonEl.innerHTML = '<div class="spinner"></div>';
                buttonEl.disabled = true;

                // Sortiere die Events, um sie chronologisch vorzulesen
                events.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                let combinedText = '';

                // Anweisung für eine schnelle Sprechweise für den gesamten Text
                combinedText += `Say in a fast pace: `;
                const firstEventDate = new Date(events[0].date);
                const monthName = firstEventDate.toLocaleString('de-DE', { month: 'long' });
                combinedText += `Dienstplan für ${monthName}. `;

                // Bestimme die ISO-Wochennummer des ersten angezeigten Tages im Kalender
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const firstDayIndex = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1; 
                const firstDisplayedDate = new Date(year, month, 1);
                firstDisplayedDate.setDate(firstDisplayedDate.getDate() - firstDayIndex);
                const startWeekNumber = getISOWeek(firstDisplayedDate);

                let lastProcessedWeek = -1;

                let i = 0;
                while (i < events.length) {
                    const currentEvent = events[i];
                    const date = new Date(currentEvent.date);
                    const currentEventWeekNumber = getISOWeek(date);

                    // Füge die Wochennummer hinzu, falls sie sich ändert
                    if (currentEventWeekNumber !== lastProcessedWeek) {
                        const weekCounter = currentEventWeekNumber - startWeekNumber + 1;
                        combinedText += `Woche ${weekCounter}. `;
                        lastProcessedWeek = currentEventWeekNumber;
                    }
                    
                    let consecutiveCount = 1;
                    const startWeekday = date.toLocaleDateString('de-DE', { weekday: 'long' });
                    let j = i + 1;

                    // Überprüfe auf aufeinanderfolgende Schichten
                    while (j < events.length) {
                        const nextEvent = events[j];
                        const prevDate = new Date(events[j-1].date);
                        const nextDate = new Date(nextEvent.date);
                        
                        const diffInDays = (nextDate.getTime() - prevDate.getTime()) / (1000 * 60 * 60 * 24);

                        if (nextEvent.shift === currentEvent.shift && diffInDays === 1) {
                            consecutiveCount++;
                            j++;
                        } else {
                            break;
                        }
                    }

                    if (consecutiveCount > 1) {
                        combinedText += `Ab ${startWeekday} ${consecutiveCount} mal die Schicht ${currentEvent.shift}. `;
                    } else {
                        combinedText += `Am ${startWeekday} ist die Schicht ${currentEvent.shift}. `;
                    }

                    i = j;
                }
                
                // Füge das Selbstlob am Ende hinzu
                combinedText += `Die Bevölkerung des Landes Tirol dankt dir für deine Aufopferung. Eine Dimme - Pommes.`;
                
                // Ruft die bestehende sayText Funktion auf
                await sayText(combinedText, buttonEl);

                buttonEl.innerHTML = originalContent;
                buttonEl.disabled = false;
            }

            function renderCalendar() {
                calendarEl.innerHTML = '';
                
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                currentMonthAndYearEl.textContent = new Date(year, month).toLocaleString('de-DE', { month: 'long', year: 'numeric' });

                const firstDayOfMonth = new Date(year, month, 1).getDay();
                const firstDayIndex = (firstDayOfMonth === 0) ? 6 : firstDayOfMonth - 1; 
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const prevDaysInMonth = new Date(year, month, 0).getDate();

                for (let i = 0; i < firstDayIndex; i++) {
                    const dayEl = document.createElement('div');
                    dayEl.className = 'calendar-day is-not-current-month text-gray-400 p-2 text-sm';
                    const prevDay = prevDaysInMonth - (firstDayIndex - i) + 1;
                    dayEl.textContent = prevDay;
                    calendarEl.appendChild(dayEl);
                }

                for (let i = 1; i <= daysInMonth; i++) {
                    const dayEl = document.createElement('div');
                    const dayFullDate = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                    const dayOfWeek = new Date(year, month, i).getDay();
                    
                    dayEl.className = `calendar-day p-4 rounded-lg text-sm transition-colors duration-100 flex flex-col items-center justify-center relative`;
                    dayEl.dataset.date = dayFullDate;

                    if (dayOfWeek === 0 || dayOfWeek === 6) {
                        dayEl.classList.add('bg-yellow-100');
                    }

                    dayEl.textContent = i;
                    
                    const existingEvent = events.find(e => e.date === dayFullDate);
                    if (existingEvent) {
                        dayEl.classList.add('has-event');
                        dayEl.draggable = true;

                        let bgColorClass, textColorClass;
                        if (existingEvent.type === 'predefined') {
                            if (existingEvent.shift.startsWith('RDN')) {
                                bgColorClass = 'bg-emerald-500';
                                textColorClass = 'text-white';
                            } else {
                                bgColorClass = 'bg-emerald-400';
                                textColorClass = 'text-white';
                            }
                        } else {
                            bgColorClass = 'bg-purple-400';
                            textColorClass = 'text-white';
                        }
                        
                        dayEl.classList.add(bgColorClass);
                        
                        const eventTextEl = document.createElement('div');
                        eventTextEl.textContent = existingEvent.shift;
                        eventTextEl.className = `text-xs mt-1 ${textColorClass} font-bold absolute bottom-1 truncate w-full px-1`;
                        dayEl.appendChild(eventTextEl);
                    }

                    // Event-Listener für das Modal-Fenster
                    dayEl.addEventListener('click', () => {
                        // Verhindert, dass das Modal beim Ziehen geöffnet wird
                        if (!dayEl.classList.contains('is-dragging')) {
                            openModal(dayFullDate);
                        }
                    });
                    
                    // Drag-and-Drop Event-Listener
                    dayEl.addEventListener('dragstart', (e) => {
                        if (existingEvent) {
                            e.dataTransfer.setData('text/plain', JSON.stringify(existingEvent));
                            draggedEventData = existingEvent;
                            e.target.classList.add('is-dragging');
                        }
                    });
                    dayEl.addEventListener('dragend', (e) => {
                         e.target.classList.remove('is-dragging');
                         draggedEventData = null;
                         if (dragTargetEl) {
                             dragTargetEl.classList.remove('drag-over');
                             dragTargetEl = null;
                         }
                    });
                    dayEl.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (dragTargetEl) {
                            dragTargetEl.classList.remove('drag-over');
                        }
                        dragTargetEl = e.target.closest('.calendar-day:not(.is-not-current-month)');
                        if (dragTargetEl) {
                            dragTargetEl.classList.add('drag-over');
                        }
                    });
                    dayEl.addEventListener('dragleave', (e) => {
                        if (dragTargetEl) {
                            dragTargetEl.classList.remove('drag-over');
                            dragTargetEl = null;
                        }
                    });
                    dayEl.addEventListener('drop', (e) => {
                        e.preventDefault();
                        if (draggedEventData) {
                            const newDate = e.target.closest('.calendar-day').dataset.date;
                            if (newDate && newDate !== draggedEventData.date) {
                                // Finden und aktualisieren des Ereignisses
                                const eventIndex = events.findIndex(e => e.date === draggedEventData.date);
                                if (eventIndex !== -1) {
                                    // Zuerst prüfen, ob es bereits einen Termin am neuen Datum gibt
                                    const existingEventAtNewDate = events.find(e => e.date === newDate);
                                    if (!existingEventAtNewDate) {
                                        events[eventIndex].date = newDate;
                                        updateEventList();
                                        renderCalendar();
                                    }
                                }
                            }
                        }
                        if (dragTargetEl) {
                            dragTargetEl.classList.remove('drag-over');
                            dragTargetEl = null;
                        }
                    });

                    // Touch-Event-Listener für Long-Touch Drag-and-Drop
                    dayEl.addEventListener('touchstart', (e) => {
                        if (existingEvent) {
                            e.preventDefault(); // Verhindert das Standard-Scroll-Verhalten
                            const touch = e.touches[0];
                            touchStartX = touch.clientX;
                            touchStartY = touch.clientY;
                            longPressTimer = setTimeout(() => {
                                // Long-Touch erkannt, starten des "Drag"
                                draggedEventData = existingEvent;
                                e.target.classList.add('is-dragging');
                                dragGhost.textContent = existingEvent.shift;
                                dragGhost.style.display = 'block';
                                dragGhost.style.left = `${touch.clientX}px`;
                                dragGhost.style.top = `${touch.clientY}px`;
                            }, longPressDuration);
                        }
                    });

                    dayEl.addEventListener('touchmove', (e) => {
                        // Wenn der Finger zu weit bewegt wird, Drag-Timer abbrechen
                        const touch = e.touches[0];
                        if (Math.abs(touch.clientX - touchStartX) > 10 || Math.abs(touch.clientY - touchStartY) > 10) {
                            clearTimeout(longPressTimer);
                        }

                        // Drag-Ghost folgen lassen
                        if (draggedEventData) {
                            const touch = e.touches[0];
                            dragGhost.style.left = `${touch.clientX}px`;
                            dragGhost.style.top = `${touch.clientY}px`;

                            // Highlighten des Drag-Ziels
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            const newDragTargetEl = targetElement ? targetElement.closest('.calendar-day:not(.is-not-current-month)') : null;
                            if (dragTargetEl && dragTargetEl !== newDragTargetEl) {
                                dragTargetEl.classList.remove('drag-over');
                            }
                            if (newDragTargetEl) {
                                newDragTargetEl.classList.add('drag-over');
                                dragTargetEl = newDragTargetEl;
                            } else {
                                dragTargetEl = null;
                            }
                        }
                    });

                    dayEl.addEventListener('touchend', (e) => {
                        clearTimeout(longPressTimer);
                        if (draggedEventData) {
                            dragGhost.style.display = 'none';
                            e.target.classList.remove('is-dragging');
                            const touch = e.changedTouches[0];
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            const dropTargetEl = targetElement ? targetElement.closest('.calendar-day:not(.is-not-current-month)') : null;

                            if (dropTargetEl) {
                                const newDate = dropTargetEl.dataset.date;
                                if (newDate && newDate !== draggedEventData.date) {
                                    const eventIndex = events.findIndex(e => e.date === draggedEventData.date);
                                    if (eventIndex !== -1) {
                                        const existingEventAtNewDate = events.find(e => e.date === newDate);
                                        if (!existingEventAtNewDate) {
                                            events[eventIndex].date = newDate;
                                            updateEventList();
                                            renderCalendar();
                                        }
                                    }
                                }
                                dropTargetEl.classList.remove('drag-over');
                            }
                            draggedEventData = null;
                            dragTargetEl = null;
                        }
                    });

                    calendarEl.appendChild(dayEl);
                }

                const totalCells = firstDayIndex + daysInMonth;
                const remainingCells = 42 - totalCells; 
                for (let i = 1; i <= remainingCells; i++) {
                    const dayEl = document.createElement('div');
                    dayEl.className = 'calendar-day is-not-current-month text-gray-400 p-2 text-sm';
                    dayEl.textContent = i;
                    calendarEl.appendChild(dayEl);
                }
            }

            function updateEventList() {
                eventListEl.innerHTML = '';
                totalEventsEl.textContent = events.length;

                events.sort((a, b) => new Date(a.date) - new Date(b.date));

                events.forEach((event, index) => {
                    const li = document.createElement('li');
                    li.className = 'bg-gray-100 p-4 rounded-lg flex items-center justify-between shadow-sm';
                    
                    const textContainer = document.createElement('div');
                    textContainer.className = 'flex items-center';
                    const formattedDate = new Date(event.date).toLocaleDateString('de-DE', { day: '2-digit', month: 'long' });
                    
                    const shiftClass = event.type === 'predefined' ? 'text-emerald-700' : 'text-purple-700';

                    textContainer.innerHTML = `<span class="text-gray-700 font-medium">${formattedDate} - </span><span class="${shiftClass} font-bold">${event.shift}</span>`;

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'flex gap-2 items-center';
                    
                    // Die individuellen Buttons zur Sprachausgabe wurden entfernt
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'bg-red-500 hover:bg-red-600 text-white font-bold h-6 w-6 rounded-full flex items-center justify-center transition-colors';
                    deleteBtn.addEventListener('click', () => {
                        events.splice(index, 1);
                        updateEventList();
                        renderCalendar();
                    });

                    buttonContainer.appendChild(deleteBtn);
                    
                    li.appendChild(textContainer);
                    li.appendChild(buttonContainer);
                    eventListEl.appendChild(li);
                });
            }

            function addEvent(shift) {
                if (selectedDate) {
                    const eventType = predefinedShifts.includes(shift) ? 'predefined' : 'freeText';
                    const existingEventIndex = events.findIndex(e => e.date === selectedDate);
                    if (existingEventIndex !== -1) {
                        events[existingEventIndex].shift = shift;
                        events[existingEventIndex].type = eventType;
                    } else {
                        events.push({ date: selectedDate, shift: shift, type: eventType });
                    }
                    updateEventList();
                    renderCalendar();
                    closeModal();
                }
            }

            dayShiftButtonsEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('shift-btn')) {
                    addEvent(e.target.dataset.shift);
                }
            });
            nightShiftButtonsEl.addEventListener('click', (e) => {
                if (e.target.classList.contains('shift-btn')) {
                    addEvent(e.target.dataset.shift);
                }
            });

            saveFreeTextBtn.addEventListener('click', () => {
                const freeTextValue = freeTextEl.value.trim().toUpperCase(); 
                if (freeTextValue === "SILLIAN LOTSE") {
                    closeModal();
                    easterEggModal.showModal();
                } else if (freeTextValue) {
                    addEvent(freeTextValue);
                }
            });

            closeModalBtn.addEventListener('click', closeModal);
            closeEasterEggModalBtn.addEventListener('click', closeEasterEggModal);

            prevMonthBtn.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() - 1);
                renderCalendar();
            });
            nextMonthBtn.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() + 1);
                renderCalendar();
            });

            // Event-Listener für den neuen Kontroll-Button
            controlButton.addEventListener('click', () => {
                readAllEvents(controlButton);
            });

            downloadIcsBtn.addEventListener('click', () => {
                if (events.length === 0) {
                    showMessage('Es sind keine Termine zum Herunterladen vorhanden.');
                    return;
                }
                
                const firstEventDate = new Date(events[0].date);
                const monthName = firstEventDate.toLocaleString('de-DE', { month: 'long' });
                const filename = `dienstplan-${monthName.toLowerCase()}.ics`;

                let icsContent = `BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//Dienstplan Ersteller//DE\n`;

                events.forEach(event => {
                    const date = new Date(event.date);
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const nextDayDate = new Date(date);
                    nextDayDate.setDate(date.getDate() + 1);
                    const nextDayYear = nextDayDate.getFullYear();
                    const nextDayMonth = String(nextDayDate.getMonth() + 1).padStart(2, '0');
                    const nextDay = String(nextDayDate.getDate()).padStart(2, '0');
                    
                    icsContent += `BEGIN:VEVENT\nUID:${event.date}-${event.shift}@dienstplan.creator\nDTSTAMP:${new Date().toISOString().replace(/[-:]/g, '').split('.')[0]}Z\nDTSTART;VALUE=DATE:${year}${month}${day}\nDTEND;VALUE=DATE:${nextDayYear}${nextDayMonth}${nextDay}\nSUMMARY:${event.shift}\nEND:VEVENT\n`;
                });

                icsContent += `END:VCALENDAR`;

                const blob = new Blob([icsContent], { type: 'text/calendar' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            });

            renderCalendar();
            updateEventList();
        });
    </script>
</body>
</html>
